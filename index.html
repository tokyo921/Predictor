#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
üéØ Bot de Sinais para Aviator (fict√≠cio) ‚Äî arquivo √∫nico
========================================================
‚ö†Ô∏è Aviso importante:
Este programa √© apenas para fins educacionais/entretenimento. O jogo Aviator
tem resultados aleat√≥rios; n√£o existem previs√µes garantidas. Jogue com
responsabilidade e nunca arrisque dinheiro que voc√™ n√£o pode perder.

Como usar (GitHub-ready):
1) Salve este arquivo como `aviator_sinais_bot.py`
2) Execute no terminal:
   python aviator_sinais_bot.py
3) Use o menu interativo (manual/autom√°tico/configura√ß√µes/exportar CSV).

Requisitos:
- Python 3.8+ (nenhuma biblioteca externa)

Funcionalidades:
- Gera√ß√£o de sinais fict√≠cios com base, risco e intervalo configur√°veis
- Modo manual (um sinal) e autom√°tico (sinais cont√≠nuos)
- Contagem regressiva visual quando houver atraso de entrada
- Exporta√ß√£o opcional dos sinais para CSV (hist√≥rico)
- Idioma: Portugu√™s (pt-BR)
"""

import csv
import json
import os
import random
import sys
import time
from datetime import datetime
from typing import Dict, Any, List

# ============================== Configura√ß√µes & Persist√™ncia ==============================

APP_NAME = "AviatorSinaisBot"
CONFIG_ARQ = "config_sinais.json"
HIST_ARQ = "historico_sinais.csv"

DEFAULTS: Dict[str, Any] = {
    "base": 2.0,         # valor base da aposta
    "risco": "medio",    # baixo | medio | alto
    "intervalo": 10,     # segundos entre sinais autom√°ticos
    "csv_auto": True,    # salvar automaticamente os sinais no CSV
    "contagem": True     # mostrar contagem regressiva de entrada
}

RISK_MAP = {
    "baixo": 0.5,
    "medio": 1.0,
    "alto": 1.7
}

def carregar_config() -> Dict[str, Any]:
    if os.path.exists(CONFIG_ARQ):
        try:
            with open(CONFIG_ARQ, "r", encoding="utf-8") as f:
                cfg = json.load(f)
            # garantir chaves padr√£o
            for k, v in DEFAULTS.items():
                cfg.setdefault(k, v)
            return cfg
        except Exception:
            pass
    return DEFAULTS.copy()

def salvar_config(cfg: Dict[str, Any]) -> None:
    try:
        with open(CONFIG_ARQ, "w", encoding="utf-8") as f:
            json.dump(cfg, f, ensure_ascii=False, indent=2)
    except Exception as e:
        print(f"[!] Falha ao salvar config: {e}")

CONFIG = carregar_config()

# ============================== N√∫cleo de Gera√ß√£o de Sinais ==============================

def gerar_sinal(cfg: Dict[str, Any]) -> Dict[str, Any]:
    base = float(cfg.get("base", DEFAULTS["base"]))
    risco = str(cfg.get("risco", DEFAULTS["risco"])).lower()
    fator = RISK_MAP.get(risco, 1.0)

    # stake sugerida limitada entre 0.5x e 3x da base, ajustada pelo risco
    stake = round(max(base * 0.5, min(base * (0.9 + fator), base * 3.0)), 2)

    estrategias = [
        "Flat (sem progress√£o)",
        "Gest√£o 1-2 (aumentar levemente ap√≥s perda)",
        "Stop r√°pido (1 gale no m√°ximo)"
    ]
    estrategia = random.choice(estrategias)

    # atraso de entrada (simula√ß√£o de janela/timing)
    atraso_seg = random.choice([0, 5, 10, 15, 20, 30])

    # alvos/limites meramente ilustrativos (n√£o preditivos)
    stop_win = round(stake * (1.2 + random.random() * 0.8), 2)
    stop_loss = round(stake * (1.0 + random.random() * 1.0), 2)

    # confian√ßa cosm√©tica (n√£o tem base real)
    confianca = random.choice(["baixa", "m√©dia", "alta"])

    return {
        "hora": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "stake": stake,
        "estrategia": estrategia,
        "atraso": atraso_seg,
        "stop_win": stop_win,
        "stop_loss": stop_loss,
        "confianca": confianca,
        "risco": risco,
        "base": base,
    }

def exibir_sinal(sinal: Dict[str, Any], cfg: Dict[str, Any]) -> None:
    quando = "agora" if sinal["atraso"] == 0 else f"em {sinal['atraso']}s"
    moldura = "‚ïê" * 42
    print(f"\n{moldura}\nüéØ Sinal Aviator ‚Äî {sinal['hora']}\n{moldura}")
    print(f"Entrada: {quando}")
    print(f"Stake sugerida: {sinal['stake']}")
    print(f"Estrat√©gia: {sinal['estrategia']}")
    print(f"Stop-win: {sinal['stop_win']} | Stop-loss: {sinal['stop_loss']}")
    print(f"Confian√ßa: {sinal['confianca']} | Risco: {sinal['risco']} | Base: {sinal['base']}")
    print("‚ö†Ô∏è Este sinal √© FICT√çCIO e N√ÉO garante resultados.")

    # Contagem regressiva est√©tica para a entrada
    if cfg.get("contagem", True) and sinal["atraso"] > 0:
        contagem_regressiva(sinal["atraso"])

def contagem_regressiva(segundos: int) -> None:
    print("\n‚è≥ Preparando entrada:", end=" ")
    for s in range(segundos, 0, -1):
        print(f"{s}", end="", flush=True)
        time.sleep(1)
        print("\b" * len(str(s)), end="", flush=True)  # apaga o n√∫mero anterior
    print("‚úÖ")

def salvar_csv(sinal: Dict[str, Any], arquivo: str = HIST_ARQ) -> None:
    novo_arquivo = not os.path.exists(arquivo)
    campos = [
        "hora", "entrada_em_seg", "stake", "estrategia",
        "stop_win", "stop_loss", "confianca", "risco", "base"
    ]
    try:
        with open(arquivo, "a", newline="", encoding="utf-8") as f:
            writer = csv.DictWriter(f, fieldnames=campos)
            if novo_arquivo:
                writer.writeheader()
            writer.writerow({
                "hora": sinal["hora"],
                "entrada_em_seg": sinal["atraso"],
                "stake": sinal["stake"],
                "estrategia": sinal["estrategia"],
                "stop_win": sinal["stop_win"],
                "stop_loss": sinal["stop_loss"],
                "confianca": sinal["confianca"],
                "risco": sinal["risco"],
                "base": sinal["base"],
            })
    except Exception as e:
        print(f"[!] Falha ao escrever CSV: {e}")

# ============================== Interface de Linha de Comando ==============================

def limpar_tela():
    try:
        os.system("cls" if os.name == "nt" else "clear")
    except Exception:
        pass

def cabe√ßalho():
    print("=== BOT DE SINAIS AVIATOR (FICT√çCIO) ===")
    print("Aviso: N√£o h√° previs√£o real. Use por sua conta e risco.")
    print("-----------------------------------------")

def menu() -> None:
    while True:
        limpar_tela()
        cabe√ßalho()
        print("1) Gerar um sinal agora")
        print("2) Come√ßar sinais autom√°ticos")
        print("3) Alterar configura√ß√µes")
        print("4) Exportar um sinal para CSV")
        print("5) Ver configura√ß√µes atuais")
        print("0) Sair")
        opcao = input("\nEscolha uma op√ß√£o: ").strip()

        if opcao == "1":
            sinal = gerar_sinal(CONFIG)
            exibir_sinal(sinal, CONFIG)
            if CONFIG.get("csv_auto", True):
                salvar_csv(sinal)
                print("üíæ (Salvo automaticamente no hist√≥rico CSV)")
            esperar_enter()

        elif opcao == "2":
            try:
                print(f"\nIniciando sinais autom√°ticos a cada {CONFIG['intervalo']}s... (Ctrl+C para parar)")
                while True:
                    sinal = gerar_sinal(CONFIG)
                    exibir_sinal(sinal, CONFIG)
                    if CONFIG.get("csv_auto", True):
                        salvar_csv(sinal)
                        print("üíæ (Salvo automaticamente no hist√≥rico CSV)")
                    time.sleep(int(CONFIG["intervalo"]))
            except KeyboardInterrupt:
                print("\n‚èπ Sinais autom√°ticos interrompidos.")
                esperar_enter()

        elif opcao == "3":
            alterar_configuracoes()

        elif opcao == "4":
            sinal = gerar_sinal(CONFIG)
            exibir_sinal(sinal, CONFIG)
            salvar_csv(sinal)
            print("‚úÖ Sinal exportado para CSV.")
            esperar_enter()

        elif opcao == "5":
            mostrar_config()
            esperar_enter()

        elif opcao == "0":
            print("üëã Saindo...")
            break

        else:
            print("‚ùå Op√ß√£o inv√°lida.")
            time.sleep(1.2)

def mostrar_config():
    print("\n--- Configura√ß√µes Atuais ---")
    for k, v in CONFIG.items():
        print(f"{k}: {v}")

def alterar_configuracoes():
    print("\n--- Alterar Configura√ß√µes ---")
    # base
    try:
        base_nova = input(f"Base atual {CONFIG['base']} ‚Üí novo valor (ENTER p/ manter): ").strip()
        if base_nova:
            CONFIG["base"] = float(base_nova.replace(",", "."))
    except ValueError:
        print("Valor inv√°lido para base. Mantendo anterior.")

    # risco
    risco_novo = input(f"Risco atual {CONFIG['risco']} (baixo/medio/alto) ‚Üí novo (ENTER p/ manter): ").strip().lower()
    if risco_novo in RISK_MAP:
        CONFIG["risco"] = risco_novo
    elif risco_novo:
        print("Risco inv√°lido. Mantendo anterior.")

    # intervalo
    try:
        inter_novo = input(f"Intervalo atual {CONFIG['intervalo']}s ‚Üí novo (ENTER p/ manter): ").strip()
        if inter_novo:
            val = int(inter_novo)
            if 1 <= val <= 600:
                CONFIG["intervalo"] = val
            else:
                print("Intervalo deve estar entre 1 e 600 segundos.")
    except ValueError:
        print("Valor inv√°lido para intervalo. Mantendo anterior.")

    # csv_auto
    csv_auto_novo = input(f"Salvar CSV autom√°tico (atual {CONFIG['csv_auto']}) [s/n] (ENTER p/ manter): ").strip().lower()
    if csv_auto_novo in ("s", "sim"):
        CONFIG["csv_auto"] = True
    elif csv_auto_novo in ("n", "nao", "n√£o"):
        CONFIG["csv_auto"] = False

    # contagem regressiva
    contagem_nova = input(f"Mostrar contagem regressiva (atual {CONFIG['contagem']}) [s/n] (ENTER p/ manter): ").strip().lower()
    if contagem_nova in ("s", "sim"):
        CONFIG["contagem"] = True
    elif contagem_nova in ("n", "nao", "n√£o"):
        CONFIG["contagem"] = False

    salvar_config(CONFIG)
    print("‚úÖ Configura√ß√µes atualizadas e salvas.")

def esperar_enter():
    try:
        input("\nPressione ENTER para continuar...")
    except (EOFError, KeyboardInterrupt):
        pass

# ============================== Execu√ß√£o ==============================

def main():
    # Execu√ß√£o direta por argumentos (opcional, √∫til para automa√ß√£o/GitHub Actions)
    # Exemplos:
    #   python aviator_sinais_bot.py --once
    #   python aviator_sinais_bot.py --auto 5
    #   python aviator_sinais_bot.py --export
    args = sys.argv[1:]
    if args:
        if args[0] == "--once":
            sinal = gerar_sinal(CONFIG)
            exibir_sinal(sinal, CONFIG)
            if CONFIG.get("csv_auto", True):
                salvar_csv(sinal)
            return
        if args[0] == "--auto":
            intervalo = int(args[1]) if len(args) > 1 else int(CONFIG["intervalo"])
            try:
                print(f"Iniciando modo autom√°tico a cada {intervalo}s... (Ctrl+C para sair)")
                while True:
                    sinal = gerar_sinal(CONFIG)
                    exibir_sinal(sinal, CONFIG)
                    if CONFIG.get("csv_auto", True):
                        salvar_csv(sinal)
                    time.sleep(intervalo)
            except KeyboardInterrupt:
                print("\nEncerrado pelo usu√°rio.")
            return
        if args[0] == "--export":
            sinal = gerar_sinal(CONFIG)
            exibir_sinal(sinal, CONFIG)
            salvar_csv(sinal)
            print("Exportado para CSV.")
            return

    # Modo interativo (menu)
    menu()

if __name__ == "__main__":
    main()

